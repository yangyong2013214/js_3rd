## 引用类型

### Object类型
	到目前为止，我们看到的大多数引用类型值都是Object类型的实例；而且，Object也是ECMAScript中使用最多的一个类型。虽然Object的实例不具备多少功能，但对于应用程序中存储和传输数据而言，它们确实是非常理想的选择。
### Array类型
	除了Object之外，Array类恐怕是ECMAScript中最常用的类型了。而且ECMAScript中的数组与其他多数语言中的数组有相当大的区别。虽然ECMAScript数组与其他语言中的数组都是数据的有序列表，但与其他语言不同的是，ECMAScript数组的每一项可以保存任何类型的数据。也就是说，可以用数组的第一个位置来保存字符串，用第二个位置来保存数值，用第三个位置来保存对象，以此类推。而且，ECMAScript数组的大小是可以动态调整的，即可以随着数据的添加自动增长以容纳新增数据。
	数组的length属性很有特点——它不是只读的。因此，通过设置这个属性，可以从数组的末尾移除项或向数组中添加新项。
	当把一个值放在超出当前数组大小的位置上时，数组就会重新计算其长度值，即长度值等于最后一项的索引加1.
	数组最多可以包含4,294,967,295个项，这几乎已经能够满足任何编程需求了。如果想添加的项数超过这个上限值，就会发生异常。而创建一个初始大小与这个上限值接近的数组，则可能会导致运行时间超长的脚本错误。
##### 转换方法
	所有对象都具有toLocaleString(),toString()和 valueOf()方法。其中，调用数组的toString()方法会返回由数组中每个值的字符串形式拼接而成的一个以逗号分隔的字符串。而调用valueOf()返回的还是数组。
	数组继承的toLocaleString(),toString()和 valueOf()方法，在默认情况下都会以逗号分隔的字符串的形式返回数组项。而如果使用join()方法，则可以使用不同的分隔符来构建这个字符串。
	如果不给join()方法传入任何值，或者给它传入undefined，则使用逗号作为分隔符，IE7及更早版本会错误的使用字符串undefined作为分隔符。
	如果数组中的某一项的值是null或者undefined，那么该值在join()，toLocaleString()、toString()和valueOf()方法返回的结果中以空字符串表示。
##### 栈方法
	ECMAScript数组也提供了一种让数组的行为类似于其他数据结构的方法。具体说来，数组可以表现得就像栈一样，后者是一种可以限制插入和删除项的数组结构。栈是一种LIFO(Last-In-First-Out，后进先出)的数据结构，也就是最新添加的项最早被移除。而栈中项的插入和移除，只发生在一个位置——栈的顶部。ECMAScript为数组专门提供了push()和pop()方法，以便实现类似栈的行为。
	push方法可以接收任意数量的参数，把它们逐个添加到数组末尾，并返回修改后数组的长度。而pop方法则从数组末尾移除最后一项，减少数组的length值，然后返回移除的项。
##### 队列方法
	栈数据结构的访问规则则是LIFO(后进先出)，而队列数据结构的访问规则是FIFO(First-In-First-Out，先进先出)。队列在列表的末端添加项，从列表的前端移除项。由于push()是向数组末端添加项的方法，因此要模拟队列只需一个从数组前端取得项的方法。实现这一操作的数组方法就是shift(),它能够移除数组中的第一个项并返回该项，同时将数值长度减1。结合使用shift()和push()方法，可以像使用队列一样使用数组。
	ECMAScript还为数组提供了unshift()方法，顾名思义，unshift()与shift()的用途相反：它能在数组前端添加任意个项并返回新数组的长度。因此，同时使用unshift()和pop()方法，可以从相反的方向来模拟队列，即在数组的前端添加项，从数组末端移除项。

##### 重排序方法
	数组中已经存在两个可以直接用来重排序的方法：reverse()和sort()。比较函数接收两个参数，如果第一个参数应该位于第二个之前则返回一个负数，如果两个参数相等则返回0，如果第一个参数应该位于第二个之后则返回一个正数。

##### 操作方法
	concat()方法可以基于当前数组中的所有项创建一个新数组。具体来说，这个方法会创建当前数组的一个副本，然后将接收到的参数添加到这个副本的末尾，最后返回新构建的数组。在没有给concat()方法传递参数的情况下，它只是复制当前数组并返回副本。如果传递给concat()方法的是一个或多个数组，则该方法会将这些数组中的每一项添加到结果数组中。如果传递的值不是数组，这些值就会被简单地添加到结果数组的末尾。

	slice()，它能够基于当前数组中的一或多个项创建一个新数组。slice()方法可以接收一或两个参数，即要返回项的起始和结束位置。在只有一个参数的情况下，slice()方法返回从该参数指定位置末尾的所有项。如果有两个参数，该方法返回起始和结束位置之间项——但不包括结束位置的项。slice()方法不会影响原始数组。

	splice()方法，算是最强大的数组方法了，它有很多种用法。splice()的主要用途是向数组的中部插入项。使用方式有如下几种：
1. 删除： 可以删除任意数量的项，只需指定2个参数：要删除的第一项的位置和要删除的项数。如：splice(0, 2) 会删除数组中的前两项。
2. 插入：可以向指定位置插入任意数量的项，只需要提供3个参数：起始位置、0（要删除的项数）和要插入的项。如果要插入多个项，可以再传入第四、第五、以至任意多个项。如：splice(2, 0, 'red', 'green')会从当前数组的位置2开始插入字符串“red‘和“green”.
3. 替换：可以向指定位置插入任意数量的项，且同时删除任意数量的项，只需指定3个参数，起始位置、要删除的项数和要插入的任意数量的项。插入的项数不必与删除的项数相等。如：splice(2, 1, 'red', 'green'),会删除当前数组位置2的项，然后再从位置2开始插入字符串“red‘和“green”.

     splice()方法始终都会返回一个数组，该数组中包含从原始数组中删除的项（如果没有删除任何项，则返回一个空数组）。
##### 位置方法
	ECMAScript5位数组实例添加了两个位置方法：indexOf()和lastIndexOf()。这两个方法都接收两个参数:要查找的项和（可选的）表示查找起点位置的索引。其中，indexOf()方法从数组的开头（位置0）开始向后查找，lastIndexOf()方法则从数组的末尾开始向前查找。

##### 迭代方法
	ECMAScript5位数组定义了5个迭代方法，每个方法都接收两个参数：要在每一项上运行的函数和（可选的）运行该函数的作用域对象——影响this的值。传入执行方法中的 函数会接收三个参数：数组项的值、该项在数组中的位置和数组对象本身。根据使用的方法不同，这个函数执行后的返回值可能会也可能不会影响方法的返回值。5个迭代方法如下：
- 
  every()：对数组中的每一项运行给定函数，如果该函数对每一项都返回true，则返回true.		
- filter()：对数组中的每一项运行给定函数，返回该函数会返回true的项组成的数组
- forEach()：对数组中的每一项运行给定函数，这个方法没有返回值
- map()：对数组中的每一项运行给定函数，返回每次函数调用的结果组成的数组
- some()：对数组中的每一项运行给定函数，返回该函数对任一项返回true，则返回true

##### 归并方法
	ECMAScript5还新增了两个归并数组的方法：reduce()和reduceRight().这两个方法都会迭代数组的所有项，然后构建一个最终返回的值。其中，reduce()方法从数组的第一项开始，逐个遍历到最后。而reduceRight()则从数组的最后一项开始，向前遍历到第一项。
	这两个方法都接收两个参数：一个在每一项调用的函数和（可选的）作为归并基础的初始值。传入给reduce()和reduceRight()的函数接收4个参数：前一个值、当前值、项的索引和数组对象。这个函数返回任何值都会作为第一个参数自动传给一下项。第一次迭代发生在数组的第二项上，因此第一个参数是数组的第一项，第二个参数就是数组的第二项。

### Date类型
```
ECMAScript中的Date类型是在早期java中的java.util.Date类基础上构建的。为此，Date类型使用自UTC(Coordinated Universal Time， 国际协调时间)1970年1月1日午夜（零时）开始经过的毫秒数来保存日期。在使用这种数据存储格式的条件下，Date类型保存的日期能够精确到1970年1月1日之前或之后的285616年。
Date.parse()方法接收一个表示日期的字符串参数，然后尝试根据这个字符串返回相应日期的毫秒数。如果传入Date.parse()方法的字符串不能表示日期，它会返回NaN。实际上，如果直接将表示日期的字符串传递给Date构造函数，也会在后台调用Date.parse()。
Date.UTC()方法同样也返回表示日期的毫秒数，但它与Date.parse()在构造值时使用不同的信息。Date.UTC()的参数分别是年份、基于0的月份（1月是0，二月是1）、月中的哪一天（1到31）、小时数（0到23）、分钟、秒以及毫秒数。在执行参数中，只有两个参数（年和月）是必需的。如果没有提供月中的天数，则假设天数为1，如果省略其他参数，则统统默认为0.

```
  ECMA-262没有定义Date.parse()应该支持将哪种日期格式，因此这个方法的行为因实现而异，而且通常因地区而异。地区设置为美国的浏览器通常都接受下列日期格式：
- “月/日/年”，如6/13/2004
- "英文月名 日,年" ，如：January 12,2004
- "英文星期几 英文月名 日 年 时:分:秒 时区 "，如：Tue May 25 2004 12:22:33 GMT-0700
- ISO 8601扩展格式 YYYY-MM-DDTHH:mm:ss.sssZ(如: 2004-05-25T12:21:24)，只有兼容ECMAScript5的实现支持这种格式

##### 继承的方法
	与其他引用类型一样，Date类型也重写了toLocaleString()、toString()和valueOf()方法，但这些方法返回的值与其他类型中的方法不同。Date类型的toLocaleString()方法会按照与浏览器设置的地区相适宜的格式返回日期和时间。而toString()方法则通常返回带有时区信息的日期和时间，其中时间一般以军用时间（即小时的范围是0到23）表示。
	至于Date类型的valueOf()方法，则根本不返回字符串，而是返回日期的毫秒表示，因此可以方便使用比较操作符来比较日期值。
###  RegExp 类型
	ECMAScript通过RegExp类型来支持正则表达式。使用下面类似Perl的语法，就可以创建一个正则表达式。
	var expression = /pattern/ flags
	其中的模式（pattern）部分可以是任何简单或复杂的正则表达式，可以包含字符类、限定符、分组、向前查找以及反向引用。每个正则表达式都可带有一或多个标志（flags），用于标明正则表达式的行为。正则表达式的匹配模式支持下列标志：

- g：表示全局（global）模式，即模式将被应用于所有字符串，而非在发现第一个匹配项时立即停止
- i：表示不区分大小写（case-insensitive）模式，即在确定匹配项时忽略模式与字符串的大小写
- m：表示多行（multiline）模式，即在到达一行文本末尾时还会继续查找下一行中是否存在于模式匹配的项。

##### RegExp实例属性
  RegExp的每个实例都具有下列属性，通过这些属性可以取得有关模式的各种信息
- global：布尔值，表示是否设置了g标志
- ignoreCase：布尔值，表示是否设置了i标志
- lastIndex：整数，表示开始搜索下一个匹配项的字符位置，从0算起
- multiline：布尔值，表示是否设置了m标志
- source：正则表达式的字符串表示，按照字面量形式而非传入构造函数中的字符串模式返回。
##### RegExp 实例方法
	RegExp对象的主要方法是exec()，该方法是专门为捕获组而设计的。exec()接受一个参数，即要应用的模式的字符串，然后返回包含第一个匹配项信息的数组；或者在没有匹配项的情况下返回null。返回的数组虽然是Array的实例，但包含两个额外的属性：index和input。其中index表示匹配项在字符串中的位置，而input表示应用正则表达式的字符串。在数组中，第一项是与整个模式匹配的字符串，其他项时与模式中的捕获组匹配的字符串（如果模式中没有捕获组，则该数组只包含一项）
	正则表达式的第二个方法是test()，它接受一个字符串参数。在模式与该参数匹配的情况下返回true，否则返回false。在只想知道目标字符串与某个模式是否匹配，但不需要知道器文本内容的情况下，使用这个方法非常方便。
	RegExp实例继承了toLocaleString()和toString()方法都会返回正则表达式的字面量，与创建正则表达式的方式无关。

##### RegExp 构造函数属性
	RegExp 构造函数包含一些属性（这些属性在其他语言中被看成是静态属性）。这些属性适用于作用域中的所有正则表达式，并且基于所指向的最后一次正则表达式操作而变化。
| 长属性名         | 短属性名 | 说明                                  |
| ------------ | ---- | ----------------------------------- |
| input        | $_   | 最近一次要匹配的字符串                         |
| lastMatch    | $&   | 最近一次的匹配项。                           |
| lastParen    | $+   | 最近一次匹配的捕获组。                         |
| leftContext  | $`   | input字符串中lastMatch之前的文本             |
| multiline    | $*   | 布尔值，表示是否所有表达式都使用多行模式。IE和Opera未实现此属性 |
| rightContext | $'   | Input 字符串中lastMatch之后的文本            |

RegExp构造函数的各个属性返回下列值：

- input属性返回了原始字符串
- leftContext属性返回了单词short之前的字符串，而rightContext属性则返回了short之后的字符串
- lastMatch属性返回最近一次与整个正则表达式匹配的字符串，
- lastParen属性返回最近一次匹配的捕获组。
  RegExp还有多达9个用于存储捕获组的构造函数属性，访问这些属性的语法是RegExp.$1，RegExp.$2 ... RegExp.$9，分别存储第一、第二....第九个匹配的捕获组。在调用exec()或test()方法时，这些属性会被自动填充。

### Function 类型
	ECMAScript中什么最有意思，我想那莫过于函数了——而有意思的根源，则在于函数实际上是对象。每个函数都是Function类型的实例，而且都与其他引用类型一样具有属性和方法。由于函数是对象，因此函数名实际上也是一个指向函数对象的指针，不会与某个函数判定。函数通常是使用函数声明语法定义的。
	由于函数名仅仅是指向函数的指针，因此函数名与包含对象指针的其他变量没有什么不同。换句话说，一个函数可能会有多个名字。
##### 没有重载
	将函数名想象为指针，也有助于理解为什么ECMAScript中没有函数重载的概念。
##### 函数声明和函数表达式
	实际上，解析器在向中心环境中加载数据是，对函数声明和函数表达式并非一视同仁。解析器会率先读取函数声明，并使其在执行任何代码之前可用（可用访问）；至于函数表达式，则必须等到解析器执行到它所在的代码行，才会真正被解释执行。
	javascript引擎在第一遍会声明函数并将它们放到源代码树的顶部。所以，即使声明函数的代码在调用它的代码后面，javascript引擎也能把函数声明提升到顶部。
##### 作为值的函数
	ECMAScript中的函数名本身就是变量，所以函数也可以作为值来使用。也就是说，不仅可以像传递参数一样把一个函数传递给另一个函数，而且可以将一个函数作为另一个函数的结果返回。
##### 函数内部属性
	在函数内部，有两个特殊的对象，arguments和this。其中，arguments介绍过，它是一个类数组对象，包含着传入函数中的所有参数。虽然arguments的主要用途是保存函数参数，但这个对象有一个名叫callee的属性，该属性是一个指针，指向拥有这个arguments对象的函数。
	函数内部的另一个特殊对象是this，其行为与java和C#中的this大致类似。换句话说，this引用的是函数据以执行的环境对象——或者也可是是this值（当在网页的全局作用中调用函数是，this对象引用的就是window）
##### 函数属性和方法
	ECMAScript中的函数是对象，因此函数也有属性和方法。每个函数都包含两个属性：length和prototype。其中，length属性表示函数希望接收的命名参数的个数。
	在ECMAScript核心所定义的全部属性中，最耐人寻味的就要数prototype属性了。对于ECMAScript中的引用类型而已，prototype是保存它们所有实例方法的真正所在。换句话说，诸如toString()和valueOf()等方法实际上都保存在prototype名下，只不过是通过各自对象的实例访问罢了。在ECMAScript5中，prototype属性是不可枚举的。因此使用for-in 无法发现。
	每个函数都包含两个非继承而来的方法：apply()和call()。这两个方法的用途都是在特定的作用域中调用函数。实际上等于设置函数体内的this对象的值。首先apply()方法接收两个参数：一个是在其中运行函数的作用域，另一个是参数数组。其中，第二个参数可以是Array的实例，也可以是arguments对象。
	call()方法与apply()方法的作用相同，它们的区别仅在于接收的参数的方式不同。对于call()方法而言，第一个参数是this值没有变化，变化的是其余参数都直接传递给函数。换句话说，在使用call()方法时，传递给函数的参数必须逐个列举出来。
	事实上，传递参数并非apply()和call()真正的用武之地；它们真正强大的地方是能够扩充函数赖以运行的作用域。
	使用call()（或apply()）来扩充作用域的最大好处，就是对象不需要与方法有任何耦合关系。
	ECMAScript5 还定义了一个方法:bind()，这个方法会创建一个函数的实例，其this值会被绑定到传给bind()函数的值。
### 基本包装类型
	为了便于操作基本类型值，ECMAScript还提供了3个特殊的引用类型：Boolean， Number和String。这些类型与本章介绍的其他引用类型相似，但同时也具体各自基本类型相应的特殊行为。实际上，每当读取一个基本类型值的时候，后台就会创建一个对应的基本包装类型的对象，从而让我们能够调用一些方法来操作这些数据。
	引用类型与基本包装类型的主要区别就是对象的生存期。使用new操作符创建的引用类型的实例，在执行流离开当前作用域之前都一直保存在内存中。而自动创建的基本包装类型的对象，则只存在于一行代码的执行瞬间，然后立即被销毁。这意味着我们不能在运行时为基本类型值添加属性和方法。
##### Boolean类型
	Boolean对象在ECMAScript中的用处不大，因为它经常会造成人们的误解。
##### Number类型
	Number类型提供了一些用于将数值格式化为字符串的方法。
	toFixed()方法会按照指定的小数位返回数值的字符串表示。
	toExponential()方法返回以指数表示法表示的数值的字符串形式。
	toPrecision()方法可能会返回固定大小(fixed)格式，也可能返回指数（exponential）格式，具体规则这块哪种格式最合适。
##### String类型
	String类型提供了很多方法，用于辅助完成对ECMAScript中字符串的解析和操作。

1. 字符方法
  两个用于访问字符串中特定字符的方法是：charAt()和charCodeAt()。这两个方法都接收一个参数，即基于0的字符位置。

2. 字符串操作方法

   1. concat()用于将一个或多个字符串拼接起来，返回拼接得到的新字符串。
   2. ECMAScript还提供了三个基于子字符串创建新字符串的方法：slice(),substr()和substring().这三个方法都会返回被操作字符串的一个子字符串，而且也都接受一或两个参数。第一个参数指定了子字符串的开始位置，第二个参数表示子字符串到哪里结束。具体里说，slice()和substring()的第二个参数指定的是子字符串最后一个字符后面的位置。而substr()的第二个参数指定的则是返回的字符个数。如果没有给这些方法传递第二个参数，则将字符串的长度作为结束位置。与concat()方法一样，slice()、substr()和substring()也不会修改字符串本身的值——它们只是返回一个基本类型的字符串值，对原始字符串没有任何影响。

3. 字符串位置方法
  有两个可以从字符串中查找子字符串的方法：indexOf()和lastIndexOf(),这两个方法都是从一个字符串中搜索给定的子字符串，然后返回子字符串的位置，如果没有找到该子字符串，返回-1，这两个方法的区别在于：indexOf()方法从字符串的开头向后搜索子字符串，而lastIndexOf()方法是从字符串的末尾向前搜索子字符串。

4. trim()方法

5. 字符串大小写转换方法
  toLowerCase(), toLocaleLowerCase(),toUpperCase(), toLocaleUpperCase()

6. 字符串的模式匹配方法
  String类型定义了几个用于在字符串中匹配模式的方法：
      1. match()方法，在字符串上调用这个方法，本质上与调用RegExp的exec()方法相同。match()方法只接受一个参数，要么是一个正则表达式，要么是一个RegExp对象。

      2. 用于查找模式的方法是search()。这个方法的唯一参数与match()方法的参数相同：由字符串或RegExp对象指定的一个正则表达式。search()方法返回字符串中第一个匹配项的索引；如果没有找到，则返回-1.而且search()方法始终是从字符串开头向后查找模式。

      3. 为了简化替换子字符串的操作，ECMAScript提供了replace()方法，这个方法接受两个参数：第一个参数可以是一个RegExp对象或者一个字符串(这个字符串不会被转换成正则表达式)，第二个参数可以是一个字符串或者一个函数。如果第一个参数是字符串，那么只会替换第一个子字符串。要想替换所有子字符串，唯一的办法就是提供一个正则表达式，而且要指定全局（g）标志。

      4. 最后一个与模式匹配有过的方法是split(),这个方法可以基于指定的分隔符将一个字符串分割成多个子字符串，并将结果放在一个数组中。分隔符可以是字符串，也可以是一个RegExp对像（这个方法不会将字符串看成正则表达式）。split()方法可以接受可选的第二个参数，用于指定数组的大小，以便确保返回的数组不会超过既定大小。

7. localeCompare()方法

   与操作字符串有关的最后一个方法是localeCompare()，这个方法比较两个字符串，并返回下列值中的一个。

   1. 如果字符串在字母表中应该排在字符串参数之前，则返回一个负数（大多数情况下是-1，具体的值要视实现而定）
   2. 如果字符串等于字符串参数，则返回0
   3. 如果字符串在字母表中应该排在字符串参数之后，则返回一个正数（大多数情况下是1，具体的值要视实现而定）
### 单体内置对象
	ECMA-262对内置对象的定义是："由ECMAScript实现提供的，不依赖于宿主环境的对象，这些对象在ECMAScript程序执行之前就已经存在了。"意思就是说，开发人员不必显示地实例化内置对象，因为它们已经实例化了，前面我们已经介绍了大多数内置对象,如 Object，Array和String,ECMAScript还定义了两个单体内置对象：Global和Math.
##### Global对象
	Global(全局)对象可以说是ECMAScript中最特别的一个对象了，因为不管你从什么角度上看，这个对象都是不存在的。ECMAScript中的Global对象在某种意义上是作为一个终极的“兜底儿对象”来定义的。换句话说，不属于任何其他对象的属性和方法，最终都是它的属性和方法。事实上，没有全局变量或全局函数；所有在全局作用域中的定义的属性和函数，都是Global对象的属性。前面接收的那些函数：如，isNaN()、isFinit()、parseInt()已经parseFloat()，实际上全都是Global对象的方法。
  Global对象还包含其他一些方法
1. URL编码方法
  Global对象的encodeURI()和encodeURIComponent()方法对URI(Uniform Resource Indentifiers, 通用资源标识符)进行编码，以便发送给浏览器。有效的URI中不能包含某些字符，如空格，而这两个URI编码方法都可以对URI进行编码，它们用特殊的UTF-8编码替换所有无效的字符，从而让浏览器能够接受和理解。
  使用encodeURI()编码后的结果是除了空格之外的其他字符都原封不动，只有空格被替换成了%20，而encodeURIComponent()方法则会使用对应的编码替换所有非字母的数字字符。
  与encodeURI()和encodeURIComponent()方法对应的两个方法分别是decodeURI()和decodeURIComponent()。其中decodeURI()只能对使用encodeURI替换的字符进行解码，同样地decodeURIComponent()能够解码使用encodeURIComponent()编码的所有字符。

2. eval()方法

  eval()方法就像是一个完整的ECMAScript解析器，它只接受一个参数，即要执行的ECMAScript（或javascript）字符串。当解析器发现代码中调用eval()方法时， 它会将传入的参数当作实际ECMAScript语句来解析，然后把执行结果插入到原位置。

3. Global对象的属性


| 属性        | 说明           | 属性             | 说明                 |
| --------- | ------------ | -------------- | ------------------ |
| undefined | 特殊值undefined | Date           | 构造函数Date           |
| NaN       | 特殊值NaN       | Error          | 构造函数Error          |
| Infinity  | 特殊值Infinity  | EvalError      | 构造函数EvalError      |
| Object    | 构造函数Object   | RangeError     | 构造函数RangeError     |
| Array     | 构造函数Array    | ReferenceError | 构造函数ReferenceError |
| Function  | 构造函数Function | SyntaxError    | 构造函数SyntaxError    |
| Boolean   | 构造函数Boolean  | TypeError      | 构造函数TypeError      |
| String    | 构造函数String   | URIError       | 构造函数URIError       |
| Number    | 构造函数String   | RegExp         | 构造函数RegExp         |
4. window对象
   ECMAScript虽然没有指出如何直接访问Global对象，但web浏览器都是将这个全局对象作为window对象的一部分加以实现的。因此，在全局作用域中声明的所有变量和函数，就都称为了window对象的属性。

##### Math对象
	ECMAScript还为保存数学公式和信息提供了一个公共位置，即Math对象。